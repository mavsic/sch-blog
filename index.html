<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Матвей Андриенко</title>

	<!-- build:css inline -->
	<link rel="stylesheet" href="css/site.css">
	<!-- /build -->

	<link rel="shortcut icon" href="i/favicon.png">
</head>
<body>
	<div class="site">
		<header class="site__header header">
			<h1 class="header__title">Матвей Андриенко</h1>
		</header>
		<main class="site__content">
			<article class="post">
				<header class="post__header">
					<h2 class="post__title">
						<a name="pepsi-vs-coca"></a>
						<nobr>Песи-ко</nobr> против <nobr>Кока-кола</nobr> Компани<!--
						--><a href="#pepsi-vs-coca" class="post__anchor"></a>
					</h2>
					<time datetime="2015-09-29" class="post__date"></time>
				</header>
				<section class="post__content">
					<p>Пепси обладает фатальным недостатком: <nobr>Пепси-кола</nobr>&nbsp;&mdash; ужасный напиток по&nbsp;сравнению с&nbsp;божественной <nobr>Кока-колой</nobr>. Не&nbsp;могу сказать точно, в&nbsp;чем там дело, но&nbsp;<nobr>Кока-кола</nobr>&nbsp;&mdash; это да, а&nbsp;<nobr>Пепси-кола</nobr>&nbsp;&mdash; это буээ. Даже <nobr>Пепси-макс</nobr>.</p>
					<p class="image">
						<img src="stab.png" data-src="i/pepsi-vs-coca.jpg" width="500" height="400" />
					</p>
					<aside>&#185;&nbsp;&mdash; меня<br />
						&#178;&nbsp;&mdash; я</aside>
					<p>Этот недостаток заставлял многих&#185; считать, что продукция <nobr>Пепси-ко</nobr>&nbsp;&mdash; отстой по&nbsp;сравнению с&nbsp;аналогами <nobr>Кока-кола</nobr> Компани. Поэтому многие&#178; предпочитали пить Спрайт вместо <nobr>Севен-апа</nobr>, Фанту вместо Миринды и&nbsp;Пауэрейд вместо Гаторейда. Есть подозрение, что несколько лет назад кокакольные напитки действительно были круче пепсивых. Например, в&nbsp;моем детстве Миринда была редкостно ядовитым напитком, после которого язык становился оранжевым.</p>
					<p>Недавно я&nbsp;случайно обнаружил, что <nobr>Севен-ап</nobr>&nbsp;&mdash; чудесный напиток с&nbsp;интересным вкусом, и&nbsp;Спрайт по&nbsp;сравнению с&nbsp;ним&nbsp;&mdash; просто сладкая вода. Я&nbsp;попробовал Миринду, и&nbsp;она оказалась более апельсиновой и&nbsp;менее сладкой, чем Фанта! Маунтин дью вообще легендарен и&nbsp;не&nbsp;имеет аналогов со&nbsp;стороны <nobr>Кока-колы</nobr>.</p>
					<p><strong>Вывод:</strong> пейте <nobr>Кока-колу</nobr>, а&nbsp;все остальное&nbsp;&mdash; от&nbsp;Пепси.</p>
				</section>
			</article>
			<article class="post">
				<header class="post__header">
					<h2 class="post__title">
						<a name="rimraf"></a>
						Удаление папки <code>node_modules</code>: <em>source path too long</em><!--
						--><a href="#rimraf" class="post__anchor"></a>
					</h2>
					<time datetime="2015-07-23" class="post__date"></time>
				</header>
				<section class="post__content">
					<p>Менеджер пакетов npm не&nbsp;уплощает дерево зависимостей, поэтому часто создает пути невероятной вложенности. Вот, например, больше 260&nbsp;символов:</p>
					<aside>Эта проблема <a href="https://github.com/joyent/node/issues/6960">несколько</a> <a href="https://github.com/npm/npm/issues/3697">раз</a> <a href="https://github.com/yatskevich/grunt-bower-task/issues/85">обсуждалась</a> на&nbsp;гитхабе.</aside>
					<pre style="white-space: pre-wrap; word-break: break-all;"><code style="white-space: pre-wrap; word-break: break-all;">D:\my-project\node_modules\grunt-divshot\node_modules\superstatic\node_modules\broker\node_modules\deliver\node_modules\join-path\node_modules\as-array\node_modules\lodash.values\node_modules\lodash.keys\node_modules\lodash._shimkeys\node_modules\lodash._objecttypes</code></pre>
					<p>Файловая система NTFS поддерживает пути даже длиннее 32 тысяч символов, но&nbsp;у&nbsp;Win32 возникают проблемы при работе с&nbsp;путями длиннее 260 символов. Например, при попытке удалить директорию <code>node_modules</code> возникнет ошибка:</p>
					<p class="image">
						<img src="stab.png" data-src="i/rimraf.png" width="449" height="189" />
					</p>
					<p>Самый простой способ <nobr>все-таки</nobr> удалить папку со&nbsp;слишком глубокой вложенностью&nbsp;&mdash; установить <a href="https://www.npmjs.com/package/rimraf">rimraf</a> и&nbsp;воспользоваться его интерфейсом командной строки:</p>
					<pre><code class="laguage-bash">npm install rimraf -g
rimraf node_modules</code></pre>
					<p>На&nbsp;самом деле, удивительно, что стандартный проводник фейлится по&nbsp;сравнению с&nbsp;утилитой для <nobr>Node.js</nobr>.</p>
				</section>
			</article>
			<article class="post">
				<header class="post__header">
					<h2 class="post__title">
						<a name="musical-impressions"></a>
						Почему я&nbsp;не&nbsp;соглашаюсь &laquo;покидать музыку&raquo;<!--
						--><a href="#musical-impressions" class="post__anchor"></a>
					</h2>
					<time datetime="2015-07-22" class="post__date"></time>
				</header>
				<section class="post__content">
					<p>Впечатлениями о&nbsp;музыке хочется делиться, но&nbsp;лучше этого не&nbsp;делать: они не&nbsp;переносимы, и&nbsp;все закончится разочарованием. Слушать любимую песню другого человека&nbsp;&mdash; мучение. Музыка работает на&nbsp;уровне эмоций, а&nbsp;эмоции одного человека не&nbsp;понятны другим. Никто не&nbsp;почувствует того, что чувствовали вы&nbsp;во&nbsp;время прослушивания.</p>
					<p>Лучше обсуждайте книги и&nbsp;фильмы, которые работают на&nbsp;рациональном уровне. А&nbsp;музыка&nbsp;&mdash; очень личное дело.</p>
				</section>
			</article>
			<article class="post">
				<header class="post__header">
					<h2 class="post__title">
						<a name="void-teaser"></a>
						Тизер нового проекта<!--
						--><a href="#void-teaser" class="post__anchor"></a>
					</h2>
					<time datetime="2015-07-18" class="post__date"></time>
				</header>
				<section class="post__content">
					<p class="image">
						<img src="i/stab.png" data-src="i/void.gif" width="310" height="310" />
					</p>
					<p>Новый проект называется <em>vǿịd</em>, будет очень модным и&nbsp;откроется осенью.</p>
				</section>
			</article>
			<article class="post">
				<header class="post__header">
					<h2 class="post__title">
						<a name="player-sort"></a>
						Сортировка в&nbsp;музыкальных плеерах<!--
						--><a href="#player-sort" class="post__anchor"></a>
					</h2>
					<time datetime="2015-07-06" class="post__date"></time>
				</header>
				<section class="post__content">
					<p>Умная текстовая сортировка должна уметь игнорировать артикли <em>a</em>, <em>an</em>, <em>the</em> в&nbsp;начале строки. Это особенно важно для музыкальный плееров: иначе половина исполнителей, вроде <em>The Beatles</em>, <em>The Kinks</em> и&nbsp;<em>The Who</em>, окажется на&nbsp;букву „T“.</p>
					<p>Сортировка по&nbsp;алфавиту&nbsp;&mdash; пуленепробиваемый вариант. Но&nbsp;стоит также подумать о&nbsp;сортировке исполнителей по&nbsp;частоте прослушивания, альбомов по&nbsp;году выпуска и&nbsp;так далее.</p>
				</section>
			</article>
			<article class="post">
				<header class="post__header">
					<h2 class="post__title">
						<a name="medicina"></a>
						Сайт <nobr>лечебно-диагностического</nobr> центра &laquo;Медицина&#8202;+&raquo;<!--
						--><a href="#medicina" class="post__anchor"></a>
					</h2>
					<time datetime="2015-07-05" class="post__date"></time>
				</header>
				<section class="post__content">
					<aside>Наполняется и&nbsp;поддерживается сотрудниками центра.</aside>
					<p>Сделал сайт для <a href="http://medplusneft.ru/"><nobr>лечебно-диагностического</nobr> центра &laquo;Медицина&#8202;+&raquo;</a>. Сайт рассказывает о&nbsp;главном: услугах и&nbsp;ценах.</p>
					<p class="image">
						<a class="project-link" href="http://medplusneft.ru/"><img src="i/stab.png" data-src="i/medicina.png" width="960" height="777" /></a>
					</p>
					<p>Моя любимая фишка&nbsp;&mdash; &laquo;прозрачная&raquo; графика. Через иконки, границы и&nbsp;плашки на&nbsp;сайте просвечивает фоновый градиент, и&nbsp;эти элементы красиво переливаются от&nbsp;зеленого к&nbsp;фиолетовому при прокрутке страницы.</p>
					<p>Сайт работает на&nbsp;<a href="https://bolt.cm/">Bolt CMS</a>, форма записи интегрирована с&nbsp;<nobr>гугл-документами</nobr>.</p>
				</section>
			</article>
			<article class="post">
				<header class="post__header">
					<h2 class="post__title">
						<a name="vrythm"></a>
						Вертикальный ритм и врезки<!--
						--><a href="#vrythm" class="post__anchor"></a>
					</h2>
					<time datetime="2015-05-18" class="post__date"></time>
				</header>
				<section class="post__content">
					<p class="lead">Верстать хорошо так, чтобы расстояния между строками были кратны одну и тому же базовому значению. Это называется вертикальным ритмом.</p>
					<aside>В сносках размер шрифта меньше, а высота строки — как в основном тексте.</aside>
					<p>Например, высота строк этого текста — 24 пикселя, и отсуп между абзацами тоже 24 пикселя, чтобы ритм не сбивался. У крупных заголовков высота строки ровно в два раза больше: 48 пикселей — и ритм снова сохраняется.</p>
					<p>Вертикальный ритм пришел из книг, где хочется, чтобы строки на левой и правой сторонах разворота «сидели» на одних и тех же базовых линиях. Как, например, <a href="https://www.artlebedev.ru/everything/izdal/kniga-na-knizhnoy-polke/">в этом издании</a> «Книги на книжной полке» Генри Петроски, строки аккуратно выровнены по базовым линиям:</p>
					<p class="image">
						<img src="i/stab.png" data-src="i/vrythm-1.png" width="896" height="673" />
					</p>
					<p>Но иногда <nobr>все-таки</nobr> приходится вставить на полосу врезку с высотой строки, не кратной базовой. Как тогда сохранить вертикальный ритм? В этой книге общую высоту врезки «добивают» до кратной базовой за счет дополнительных отсупов до и после. Обратите внимание на различный размер отступов у врезок на этом развороте:</p>
					<p class="image">
						<img src="i/stab.png" data-src="i/vrythm-2.png" width="896" height="673" />
					</p>
					<p>Таким образом и в этой ситуации вертикальный ритм удается сохранить. Отличный прием!</p>
				</section>
			</article>
			<article class="post">
				<header class="post__header">
					<h2 class="post__title">
						<a name="jspm"></a>
						Крутость jspm<!--
						--><a href="#jspm" class="post__anchor"></a>
					</h2>
					<time datetime="2015-05-17" class="post__date"></time>
				</header>
				<section class="post__content">
					<p class="lead">Эту версию сайта я делал, используя пакетный менеджер для яваскриптового фронтэнда <a href="http://jspm.io/">jspm</a> — и мне   понравилось. Вот почему.</p>
					<aside>
						<strong>В тексте упоминаются</strong>: <br />
						пакетные менеджеры <a href="http://bower.io/">Bower</a> и <a href="http://jspm.io/">jspm</a>, <br />
						загрузчики модулей <a href="http://requirejs.org/">RequireJS</a> и <a href="https://github.com/systemjs/systemjs">SystemJS</a>, <br />
						<a href="http://requirejs.org/docs/optimization.html">RequireJS Optimizer</a>, <br />
						сборщик <a href="http://gruntjs.com/">Grunt</a>, плагины для него: <nobr><a href="https://github.com/yeoman/grunt-bower-requirejs">grunt-bower-requirejs</nobr></a> и <nobr><a href="https://github.com/dciccale/grunt-processhtml/">grunt-processhtml</a></nobr>, <br />
						<a href="https://github.com/">гитхаб</a> и <a href="https://www.npmjs.com/">npm</a>.
					</aside>
					<p>Обычно для получения фронтэндовых пакетов используют Bower. Для удобного использования <nobr>Bower-пакетов</nobr> с загрузчиком модулей приходится использовать заклинания вроде <nobr>grunt-bower-requirejs</nobr>, чтобы конфиг с путями к модулям для RequireJS создавался автоматически.</p>
					<p>В отличие от Bower, который фактически умеет только скачивать пакеты, jspm изначально создавался с расчетом на использование загручика модулей SystemJS. При инициализации проекта SystemJS скачивается автоматически, а при установке пакетов они сразу прописываются в конфиг. Пакеты устанавливаются с гитхаба и из npm, плюс ведется <a href="http://kasperlewau.github.io/registry/">модерируемый реестр</a>. Как бонус, появляется возможность использовать ES6.</p>
					<p>jspm умеет собирать код в один файл. Делаем <code>jspm <nobr>bundle-sfx</nobr></code> — и получаем единственный файл для использования на продакшене вообще без загрузчика модулей, только, <nobr>почему-то</nobr>, не минифицированный.</p>
					<p>Таким образом, четыре инструмента (Bower, RequireJS, RequireJS Optimizer и <nobr>grunt-bower-requirejs</nobr>) заменены одним jspm. Мне не хватает только встроенной склейки и минификации CSS (как в оптимизаторе RequireJS), тогда Grunt стал бы совсем не нужен. Но пока без сборщика не обойтись.</p>
					<h3 class="spoiler__toggle"><a>Бонус: Gruntfile для типичного проекта с jspm</a></h3>
					<div class="spoiler__content">
						<p class="p_nosp">Задача:</p>
						<ul class="list_compact">
							<li>собрать яваскрипт в один минифицированный файл,</li>
							<li>минифицировать CSS, выполнить подстановки <code>@import</code>,</li>
							<li>подготовить папку с готовыми для публикации файлами проекта.</li>
						</ul>
						<p>Решение: вот такой <strong><a href="https://gist.github.com/mavsic/b87f9d3ca02b7b048424">Gruntfile</a></strong>.</p>
						<p class="p_nosp">Структура проекта:</p>
						<ul class="list_compact">
							<li>Весь код в папке <code>js/</code>,</li>
							<li>основной модуль проекта называется <code>js/main</code>,</li>
							<li>все стили в папке <code>css/</code>,</li>
							<li>файл <code>index.html</code> выглядит так:</li>
						</ul>
						<pre><code class="language-markup">&lt;html&gt;
&lt;head&gt;
	&lt;meta charset="UTF-8"&gt;
	&lt;title&gt;My Super App&lt;/title&gt;
	&lt;link rel="stylesheet" href="css/site.css"&gt;
&lt;/head&gt;
&lt;body&gt;
	...

	&lt;!-- Код ниже — стандартный при использовании jspm:
	подключаем загрузчик и конфиг, загружаем основной модуль: --&gt;

	&lt;!-- build:script js/site.js --&gt;
	&lt;script src="jspm_packages/system.js"&gt;&lt;/script&gt;
	&lt;script src="config.js"&gt;&lt;/script&gt;
	&lt;script&gt;
		System.import('js/main');
	&lt;/script&gt;
	&lt;!-- /build --&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
						<p>Gruntfile первым делом выполняет команду <code>jspm bundle-sfx js/main build/js/site.js</code> в командной строке. jspm анализирует зависимости модулей друг от друга и создает файл <code>site.js</code> в подпапке <code>build/</code>, содержащий объединенный код всех используемых модулей в правильном порядке.</p>
		    			<p>Теперь было бы здорово автоматически заменять в <nobr>HTML-файлах</nobr> все теги <code>&lt;script&gt;</code> на единственный тег с подключением минифицированного файла <code>site.js</code>. Хорошо, что для этого придумали плагин <nobr>grunt-processhtml</nobr>! Если окружить теги <code>&lt;script&gt;</code> специальными комментариями (как мы и сделали в файле <code>index.html</code>):</p>
						<pre><code class="language-markup">&lt;!-- build:script js/site.js --&gt;
&lt;script src="jspm_packages/system.js"&gt;&lt;/script&gt;
&lt;script src="config.js"&gt;&lt;/script&gt;
&lt;script&gt;
	System.import('js/main');
&lt;/script&gt;
&lt;!-- /build --&gt;</code></pre>
						<p>то плагин выполнит замену:</p>
						<pre class="language-markup"><code>&lt;script src="js/site.js"&gt;&lt;/script&gt;</code></pre>
						<p>Более того, если добавить к спецкомментариям слово <code>inline</code>, то скрипт или таблица стилей будет встроена прямо в файл — еще меньше запросов к серверу! C такими поправками файл станет полностью самодостаточным:</p>
						<pre><code class="language-markup">&lt;html&gt;
&lt;head&gt;
	&lt;meta charset="UTF-8"&gt;
	&lt;title&gt;My Super App&lt;/title&gt;
	&lt;!-- build:css inline --&gt;
	&lt;link rel="stylesheet" href="css/site.css"&gt;
	&lt;!-- /build --&gt;	
&lt;/head&gt;
&lt;body&gt;
	...

	&lt;!-- build:script inline js/site.js --&gt;
	&lt;script src="jspm_packages/system.js"&gt;&lt;/script&gt;
	&lt;script src="config.js"&gt;&lt;/script&gt;
	&lt;script&gt;
		System.import('js/main');
	&lt;/script&gt;
	&lt;!-- /build --&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
						<p>Такой воркфлоу я использую для публикации этого сайта.</p>
					</div>
				</section>
			</article>
			<article class="post">
				<header class="post__header">
					<h2 class="post__title">
						Игги Поп на BBC Radio 6 Music<!--
						--><a name="iggy-radio" href="#iggy-radio" class="post__anchor"></a>
					</h2>
					<time datetime="2015-04-12" class="post__date"></time>
				</header>
				<section class="post__content">
					<aside>Хуже всего, что записи удаляются из BBC iPlayer через месяц после эфира.</aside>
					<p>Игги Поп ведет очень годный музыкальный эфир на BBC Radio 6 Music. Официально слушать эфиры в записи можно только через <a href="http://www.bbc.co.uk/programmes/b03yblbx/broadcasts/2015/05">BBC iPlayer</a>, что не всегда удобно. Я <a href="iggy/">сделал сайт</a>, куда выкладываются записи эфиров и <nobr>трек-листы</nobr>:</p>
					<p class="image">
						<a class="project-link" href="iggy/"><img src="i/stab.png" data-src="i/iggy-radio.png" width="960" height="756" /></a>
					</p>
					<p><strong>Технологии:</strong> Backbone, RequireJS, Mustache, иконочный шрифт (использую <a href="https://icomoon.io/app/">IcoMoon App</a>, крутой инструмент), HTML5 Audio (написал клевую обертку над стандартным HTMLMediaElement, расскажу в следующий раз).</p>
					<p>Проект поддерживается моими силами, новые эпизоды могут появляться с задержкой.</p>
				</section>
			</article>
			<article class="post">
				<header class="post__header">
					<h2 class="post__title">
						<a name="irn-bru"></a>
						Irn Bru<!--
						--><a href="#irn-bru" class="post__anchor"></a>
					</h2>
					<time datetime="2015-01-21" class="post__date">21 января 2015</time>
				</header>
				<section class="post__content">
					<p class="image">
						<img src="i/stab.png" data-src="i/irn-bru.jpg" width="700" height="204" />
					</p>
					<p>Попробовал напиток, постоянно попадавшийся на глаза, но который до этого ни разу не покупал: <nobr>Irn-Bru</nobr> — второй по известности шотландский напиток после скотча. Необычно, и <em>grows on you</em>. Вот еще напиток с названием из двух слов по три буквы: Mnt Dew.</p>
				</section>
			</article>
			<article class="post">
				<header class="post__header">
					<h2 class="post__title">
						<a name="load-tweets"></a>
						Загрузка твитов яваскриптом без авторизации <s>и смс</s><!--
						--><a href="#load-tweets" class="post__anchor"></a>
					</h2>
					<time datetime="2015-01-19" class="post__date"></time>
				</header>
				<section class="post__content">
					<aside>Самому Твиттеру авторизация нужна для статистики: «This visibility [...] helps us to further understand how categories of applications are using the API». (<a href="https://dev.twitter.com/rest/public">Источник</a>)</aside>
					<p>Текущий REST API Твиттера требует обязательной авторизации. Это неудобно и глупо, например, для чтения твитов из открытого аккаунта авторизация явно лишняя.</p>
					<p>Зато при использовании виджетов авторизация не требуется, что дает возможность получить последние твиты пользователя (не более 20) чисто клиентским яваскриптом. Идея в том, чтобы загрузить виджет в скрытый контейнер на странице, а потом распарсить его содержание. Моя небольшая библиотека это и делает, использовать ее можно так:</p>
					<pre><code class="language-javascript">loadTweets('123456789012345678', 10).done(function(tweets) {
	console.log(tweets);
});</code></pre>
					<p>Здесь первый параметр — ID виджета, созданного <a href="https://twitter.com/settings/widgets">в настройках профиля</a>, второй параметр — количество твитов для загрузки. Все работает асинхронно и возвращает jQuery Deferred, который разрешается массивом твитов.</p>
					<p>Код, оформленный в виде модуля RequireJS, и крошечная документация доступны <a href="https://bitbucket.org/mavsic/loadtweets">в репозитории на битбакете</a>.</p>
				</section>
			</article>
		</main>
		<footer class="site__footer footer">
			2015
		</footer>
	</div>

	<!-- build:js inline js/site.js -->
	<script src="jspm_packages/system.js"></script>
	<script src="config.js"></script>
	<script>
		System.import('main');
	</script>
	<!-- /build -->
</body>
</html>